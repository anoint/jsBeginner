# null과 undefined
- 빈값 | 없는 값
- 비어있는, 존재하지않는 값 | 아무 값도 할당받지 않는 상태 
- 단, tyupeof로 자료형을 확인할 때 객체(Object)를 반환하는데, js 기존 이슈로 인한 결과이므로 객체형으로 오해하지 않도록 주의한다. | 

# ES6) 템플릿 문자열 
- `(억음 부호)안에 ${표현식}를 이용하여 삽입 처리가 가능하다.
삽입처리란 표현식의 계산된 결과가 문자열로 변경되어 해당 위치에 삽입된다.
``` 
 console.log(`${name} 입니다.`);
```

# 거듭제곱 연산자 (**)
```
 3 ** 3 // 27 
```

# 관계 연산자는 두 개의 값을 비교를 통해 관계를 확인한다.
## 동등 연산자(==) : 비교 대상값ㄷ의 자료형이 서로 다르면 강제로 형을 바꾼뒤에 비교한다.
## 부등 연산자(!=) : 동등 연산자와 동일하게 형을 변환하고 비교한다.
## 일치 연산자(===) : 값의 내용을 비교하는 것뿐만 아니라, 자료형까지 일치하는 비교한다.
## 불일치 연산자(!==) : 같은 자료형에서 값의 내용이 다르거나 다른 자료형인 경우 true를 반환한다.

# 삼항연산자 
- 조건문 ? 표현문1 : 표현문2
조건문은 반드시 결과가 참과 거짓으로 반환되야 한다.
결과가 true이면 표현문1을 실행하고, false이면 표현문2를 실행한다.

# 비트 연산자
## 1바이트는 8비트다.
## 비트논리 연산자와 비트 이동 연산자
- AND 비트 연산자 : &는 논리곱 연산결과이다.
- NOT 비트 연산자 : ~는 비트값을 반대의 값이다.
- OR 비트 연산자 : |는 비트값중 하나만 1이어도 1을 반환한다.
- XOR 비트 연산자 : ^는 배타적으로 1인 경우 1을 반환한다.
- << 비트 연산자 : 비트의 자리수만큼 왼쪽으로 이동한다.
- >> 비트 연산자 : 비트의 자리수만큼 오른쪽으로 이동한다.

## 숫자바이너리 형태로 변환하기
```
 150.toString(2); // 10010110
```
# 형변환
``` 
var str = 5 + "1";
var num = +str;
Number(num) 
String(num)
```
# 배열
- 기차를 연상 시킨 모습으로 대괄호[] 사이의 요소들로 구성된다.
- 인덱스 : 배열 안에 위치한 요소의 좌표

# 객체는 값들을 그룹으로 묶은 데이터 모음이다.
- 중괄호 안에 키와 값을 한 쌍으로 정의 하며 속성이라고 부른다.

## 객체의 추가/수정
- members.niece = {} 객체의 속성에 접근하는 방법은 객체의 우측에 콤마,를 두고, 키 이름을 작성한다.
- members['niece'] = {} 대괄호 안에 키 값을 작성하는 방법도 있으나 선호하지 않는다.

## 객체의 삭제
```
 delete members.aunt;
 delete members['dog'];
```
## ES6) 객체 단축 속성명
- 변수명으로 속성의 키와 값을 한번에 정의한다.
- 키 이름은 변수명으로 정의하고, 값을 해당 변수에 할당한다.
```
 var family = { address, members};
```
## ES6) 객체 속성 계산명
- 대활호안에 식을 넣거나 변수를 대입하여 동적으로 객체 속성들을 생성한다.
?? 어떤 용도로 사용되는지?

## ES6) 비구조화 할당
- 객체 비구조화 할당:  중괄호안에 속성 이름을 넣어 객체의 여러 속성을 한 번에 가져온다.
- 배열 비구조화 할당: 객체 비구조화 할당 방식에서 중괄호를 대괄호로 바꾸면 된다. 

# Symbol-심볼
- 늘 고유한 값을 반환한다.
- 심볼은 객체의 키로 사용가능하다.
- getOwnProperttySymbols : 객체의 키에 해당하는 심볼을 가져온다.

# 함수 형태를 구분하는 4가지
- 키워드 function : es6는 생략 
- 함수 이름 : 이름을 정의하지 않은 함수인 익명함수도 있음.
- 매개변수 목록 : 인자값을 전달한다.
- 함수 실행부 : 다발의 코드를 작성한다.

# 예외 처리하기
- throw문과 try-catch-finally문
- 에러 종류는 개발자가 의도한 에러와 예상치 못한 에러이다.
- throw문은 예외사항을 미리 파악하고 고의로 에러를 발생시켜 이후 코드 실행을 중단한다. 
- try는 발생된 에러를 잡아내고, catch는 변수로 전달된 오류메시지를 확인한다. finally는 무조건 실행한다.  

# arguments(전달인자) : 함수가 호출될 때 전달되는 값
- js는 전달 인자 개수와 매개변수의 개수가 달라도 에러를 발생안함.
- instanceof연산자로 배열이 아닌 것을 확인.

# ES6) 함수 기본 매개변수 정의와 할당을 함께함
```
function drawChart(width=200, heigh=400) {}
```
# ES6) 함수 나머지 매개변수 배열
- arguments 객체와 나머지 매개변수와의 차이점은 배열여부이다.
```
function(parameter, ...restParameter) {}
```

# 스코프
- 유효범위로써 변수와 매개변수가 어디까지 유효한지 나타낸다.
- 전역과 함수 단위로 생성된다.

# 함수 호이스팅
- 함수가 실제 호출하기 이전으로 끌어 올라간것 처럼 동작한다.
- 함수를 선언문이 아닌 표현식을 통해 변수에 할당하여 호출하게 되면 동작하지 않음.
- 이유는 코드를 해석하는 단계에서 선언문을 초기화하면서 스코프를 형성하고 
실행하는 단계에서 값을 할당하거나 계산을 하는 행위를 한다.

# ES6) let으로 변수 선언
- 변수의 유효 범위를 블록 범위로 지정된다.

# ES6) const로 상수 선언
- 선언 시 값을 할당해야 되고 재할당이 불가함, 블록 단위로 스코프를 정의한다.
# 스코프 체인
- 스코프 렉시컬 환경이 연결된 형태이다.
- 중첩함수에서 자식 함수가 부모 함수의 변수에 접근할 때 발생한다.
- 실행 컨텍스트란 코드가 실행되기 위해 필요한 정보를 가지고 있는 상태다.
- 렉시컬 환경은 환경 레코드와 외부 렉시컬 환경으로 구성된다. 
- 환경 레코드는 식별자와 값은 키와 값의 쌍으로 기록된다.
- 외부 렉시컬 환경은 참조를 통해 연결된 실행 컨텍스트에서 해당 식별자를 찾게 된다. 
ex) 스코프 체인으로 식별자 찾는 문장
1. 함수가 호출될 때 변수는 자신의 실행 컨텍스트의 렉시컬 환경에서 찾는다.
2. 하지만 함수 내에 선언되지 않았다.
3. 외부 렉시컬 환경의 참조를 통해 연결된 print 실행 컨텍스트에서 해당 식별자를 찾는다.
4. 또한 전역 실행 컨텍스트까지 가서 찾아 값을 출력한다.

# 클로저
- 함수가 정의될 때 렉시컬 환경을 기억하는 함수다.

# 속성기술자 객체 가져오기
- getOwnPropertyDescriptor
```
 let user = { name : 'jeado' }; 
 let descriptor  = Object.getOwnPropertyDescriptor(user, 'name');
``` 
# 객체속성 정의 
- Object.defineProperty
  (  객체,
     속성명,
     속성기술자 인자 3개
     {   vaule:값,
         enumerable:나열 가능 여부, 
         writable:값 변경 여부,
         configurable:속성 기술자 변경 여부
     }
  )
```
 let user2 = {};
 Object.defineProperty(user2, "name", {
    value : "jina",
    enumerable: true,
    configurable: true,
    writable: false
 });
```
# get, set을 통한 속성 접근
- 접근 기술자는 값에 접근하는 방식을 정의하는 객체를 전달한다.
- get 메소드는 속성에 접근할 때 호출된다.
- set 메소드는 속성에 값을 접근할 때 호출된다.
- _를 붙이는 것은 비공배 속성임을 규칙을 통해 나타낸다.

# ES6) 화살표 함수
- 매개변수가 하나일 경우에는 인자를 정의할 때 괄호를 생략한다.
```
const double = x -> x+x;
```
- 화살표 함수 코드 블록을 지정하지 않고 한 문장으로 작성 시 return문을 사용하지 않아도 
화살표의 오른쪽 표현식의 계산 결과값이 반환된다.
```
console.log(double(2)); //4
```
- return문이 없을 시 undefined가 반환된다.
# 객체지향 프로그래밍
- 프로그램을 객체들로 구성하고 객체들간에 서로 상호작용하도록 작성하는 방법
- 객체를 묶어서 하나의 타입으로 정의하는 작업을 분류
- 원형(Prototype)은 특징을 묘사하는 공통 사항을 적용한다.
```
const harin = {
__proto__ : studentProto
}
const bbo = {
__proto__ : studentProto
}
```

# 생성자 함수
- new 키워드를 사용하고 대문자로 시작한다.
- 인스턴스 : 객체의 타입이 적용된 것.
- new를 빼면 전역 객체에 전달된다. 
- instanceof는 인스턴스 여부다.

# 생성자 함수의 NEW 호출을 통한 객체 생성 과정
1. 빈 객체를 만든다.
2. 만든 빈 객체를 this에 할당한다.
3. 생성자 함수 바디의 코드를 실행한다.
4. 만든 빈 객체의 __proto__에 생성자 함수의 prtotype 속성을 대입한다.
5. this를 생성자의 반환값으로 변환한다.

# 프로토타입 기반 상속
```
const productStorage = new Storage();
```
Storage 타입의 인스턴스를 생성하면 인스턴스는 해당 생성자 함수의 프로토타입을 상속한다.

# ES6) 클래스 정의
- 별도 타입의 객체를 생성하는 설계 도면이다.
- 카트 클래스에서 만들어진 객체들은 카트 인스턴스다.
- constructor로 함수이름이 고정된다.

# 클래스 상속
- extends로 정의하고, super로 부모 생성자 함수를 가르킨다.

# 클래스 정적 메소드와 속성
- 메소드는 static으로 정의한다.
- 속성은 static get 키워드를 통해 정의

# this 사용방법
- 객체 안에 메소드로 정의, 생성자 함수, 값을 반환하는 목적으로 사용가능하다.
- 내부함수의 this는 전역 객체를 가리킵니다. 

# 모듈 정의
- 파일이나 코드의 묶음 단위로 재사용과 기능 단위로 잘게 분리하여 관리한다.
- 네임스페이스 패턴 : 즉각 호출 패턴을 통해 생성
```
(function(){//코드}); 
```
# ES6) 모듈 시스템 
- import와 export
- 런타임 로딩 : http요청으로 실행 ex) require.js
- 번들링 : 의존관계가 형성된 모듈을 하나의 파일로 묶어 준다. ex)웹팩
- 서버를 구동해야됨.

# ES6) 모듈 기본값 정의, 가져오기
- default 

# 모듈을 여러 이름으로 내보내고 가져오기
- export {}
- import {}

# 외부 모듈 사용
- as로 현재 모듈에서 다름 이름으로 사용
```
export {version as ver} from './version.js'
```